# -132
Динамический массив и умные указатели #132
#include<memory>//класс который содержит умные указатели
template<typename T>
class SmartPointer//для автоматизации работы с указателем
{
public:
	SmartPointer(T *ptr)//б.получать указатель на какой-то объект, памяьб на который мы выделили
		//и адрес в памяти, на который указ-т этот указ-ь мы б.записывать в наш ук-ль
		//что лежит в private секции и здесь б.его хранить
		//
	{
		this->ptr = ptr;

	}
	~SmartPointer()//здесмь обяз-но освобождаем место
	{
		delete ptr;
	}
	
	T& operator*()//возвращаем именно ссылка на тип T, тк хотим менно данные изменить
		//далее название того, что перегружаем - * и скобки
	{
		return *ptr;//возвращаем разымен-е данные
	}

private:
	T *ptr;//сможет работать с любым типом. Ч-з него мы м. получить доступ в памяти,где
	//хранятся данные,под котороые б. выделено место
};
int main()
{
	int size=5;
	int *arr = new int[size]{1,5,6,4,88};
	/*shared_ptr<int[]>ptr;*///shared_ptr<int[]>ptr (new int[size]{1,5,6,4,88});
	//указ-ль указ-т н аобл памяти, где лежит массив, когда выйдет из main, 
	//то освободит данные из него
	shared_ptr<int> ptr(new int[size] {1, 2, 3, 4, 5}, default_delete<int[]>());

	for (int i = 0; i < size; i++)
	{
		/*ptr[i] = rand() % 10;*/
		cout << ptr.get()[i] << endl;

	}



	return 0;
}


